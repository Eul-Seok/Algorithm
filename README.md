# 알고리즘 별 적용 문제 유형 요약

이 문서는 대표적인 알고리즘들이 어떤 종류의 문제에 효과적으로 사용될 수 있는지 요약합니다.


## 정렬 (Sorting)

- **버블 정렬 (Bubble Sort)**
  - **시간 복잡도**: O(N²) 최악/평균, **O(N) 최선**
  - **특징**: 구현이 간단하지만 비효율적. **이미 정렬된 데이터에 대해서는 O(N)만에 작업을 마칠 수 있어 최선의 성능**을 보입니다.

- **선택 정렬 (Selection Sort)**
  - **시간 복잡도**: **O(N²) 항상**
  - **특징**: 데이터의 초기 상태와 무관하게 항상 O(N²)의 시간 복잡도를 가집니다. 데이터 교환(swap) 횟수가 적다는 장점이 있습니다.

- **삽입 정렬 (Insertion Sort)**
  - **시간 복잡도**: O(N²) 최악/평균, **O(N) 최선**
  - **특징**: **데이터가 거의 정렬되어 있을 때 최고의 성능**을 보입니다. 소규모 데이터셋이나 다른 정렬(팀 정렬 등)의 일부로 사용될 때 효율적입니다.

- **병합 정렬 (Merge Sort)**
  - **시간 복잡도**: **O(N log N) 항상**
  - **특징**: **안정 정렬(stable sort)**이며, 어떤 경우에도 O(N log N) 성능을 보장합니다. 단, O(N)의 추가 메모리가 필요합니다.

- **퀵 정렬 (Quick Sort)**
  - **시간 복잡도**: **O(N log N) 평균, O(N²) 최악**
  - **특징**: 평균적으로 매우 빠르지만, **피벗(pivot)을 잘못 선택하면 성능이 급격히 저하**됩니다. (예: 이미 정렬된 배열에서 첫 원소를 피벗으로 삼는 경우)

- **힙 정렬 (Heap Sort)**
  - **시간 복잡도**: **O(N log N) 항상**
  - **특징**: 어떤 경우에도 O(N log N) 성능을 보장하며, 추가 메모리 없이(in-place) 정렬이 가능합니다.

- **기수 정렬 (Radix Sort)**
  - **시간 복잡도**: O(d * (N + k)) (d: 자릿수)
  - **특징**: 비교 기반이 아닌, **자릿수를 이용해 정렬**합니다. 정수나 특정 형식의 문자열 데이터에 대해서는 매우 빠른 성능을 보입니다.


## 탐색 (Search)

- **이분 탐색 (Binary Search)**
  - **목적**: **정렬된** 배열이나 리스트에서 특정 값을 매우 빠르게 찾습니다.
  - **시간 복잡도**: O(log N)
  - **예시**: 정렬된 데이터에서 값 찾기, 파라메트릭 서치

- **삼분 탐색 (Ternary Search)**
  - **목적**: **단봉(unimodal)** 함수 혹은 배열에서 최댓값/최솟값을 찾습니다.
  - **시간 복잡도**: O(log N)


## 그래프 탐색 (Graph Traversal)

- **깊이 우선 탐색 (DFS, Depth-First Search)**
  - **목적**: 한 경로를 끝까지 탐색한 후 다음 경로로 넘어갑니다. **스택(Stack) 또는 재귀(Recursion)**로 구현합니다.
  - **시간 복잡도**: O(V + E) (V: 정점, E: 간선)
  - **예시**: 연결 요소 찾기, 사이클 판별, 위상 정렬

- **너비 우선 탐색 (BFS, Breadth-First Search)**
  - **목적**: 시작점에서 가까운 정점부터 순서대로 탐색합니다. **큐(Queue)**로 구현합니다.
  - **시간 복잡도**: O(V + E)
  - **예시**: 가중치 없는 그래프의 최단 경로, 레벨 순서 순회


## 최소 신장 트리 (Minimum Spanning Tree, MST)

- **크루스칼 알고리즘 (Kruskal's Algorithm)**
  - **목적**: 가중치가 가장 작은 간선부터 **Union-Find로 사이클을 확인하며** 추가합니다. (희소 그래프에 유리)
  - **시간 복잡도**: O(E log E)

- **프림 알고리즘 (Prim's Algorithm)**
  - **목적**: 시작 정점에서부터 **우선순위 큐를 사용해** 가장 가까운 정점을 추가하며 트리를 확장합니다. (밀집 그래프에 유리)
  - **시간 복잡도**: O(E log V) (우선순위 큐 사용 시)


## 최단 경로 (Shortest Path)

- **다익스트라 알고리즘 (Dijkstra's Algorithm)**
  - **목적**: **한 정점에서 다른 모든 정점까지**의 최단 경로를 찾습니다. (음수 가중치 불가)
  - **시간 복잡도**: O(E log V) (우선순위 큐 사용 시)

- **플로이드-워셜 알고리즘 (Floyd-Warshall Algorithm)**
  - **목적**: **동적 계획법(DP) 기반**으로, **모든 정점에서 모든 다른 정점까지**의 최단 경로를 찾습니다. (음수 가중치 허용, 음수 사이클은 불가)
  - **시간 복잡도**: O(V³)

- **벨만-포드 알고리즘 (Bellman-Ford Algorithm)**
  - **목적**: **음수 가중치가 있는** 그래프에서 최단 경로를 찾습니다. (음수 사이클 판별 가능)
  - **시간 복잡도**: O(V * E)

- **A\* 탐색 알고리즘 (A\* Search Algorithm)**
  - **목적**: **한 정점에서 특정 목표 정점까지**의 최단 경로를 효율적으로 찾습니다. 목적지까지의 예상 거리를 추정(Heuristic)하여 불필요한 탐색을 줄입니다.
  - **시간 복잡도**: 다익스트라와 유사(O(E log V))하지만, 휴리스틱 함수의 성능에 따라 실제로는 훨씬 빠를 수 있습니다.


## 알고리즘 설계 기법

- **동적 계획법 (Dynamic Programming, DP)**
  - **목적**: 큰 문제를 작은 하위 문제로 나누어 풀고, 하위 문제들의 해를 저장하여 중복 계산을 피합니다.
  - **Top-down (메모이제이션)**: **재귀 호출**을 사용하여 큰 문제부터 작은 문제로 파고들며, 한 번 계산한 결과는 배열에 저장하여 재사용합니다.
  - **Bottom-up (타뷸레이션)**: **반복문과 점화식**을 사용하여 가장 작은 하위 문제부터 차례대로 해를 구해 전체 문제의 답을 도출합니다.
  - **시간 복잡도**: 문제에 따라 다름 (일반적으로 (하위 문제 수) × (하위 문제 해결 시간))
  - **예시**: 피보나치 수열, 최장 증가 부분 수열(LIS), 배낭 문제(Knapsack)

- **분할 정복 (Divide and Conquer)**
  - **목적**: 문제를 작은 부분 문제로 나누어 해결하고 결과를 조합합니다.
  - **시간 복잡도**: 문제에 따라 다름 (예: 병합 정렬 O(N log N))
  - **예시**: 병합 정렬, 퀵 정렬

- **백트래킹 (Backtracking)**
  - **목적**: 해를 찾는 과정에서, 더 이상 가능성이 없는 경로는 차단(**가지치기, Pruning**)하고 이전 상태로 돌아가(**상태 복구**) 다른 경우를 탐색합니다.
  - **시간 복잡도**: 문제에 따라 다름 (일반적으로 지수 시간)
  - **예시**: N-Queens, 스도쿠, 순열/조합 생성


## 기타 자료구조 및 알고리즘

- **유니온 파인드 (Union-Find)**
  - **목적**: 여러 집합을 관리하며, 두 원소가 같은 집합인지 판별하고 두 집합을 합칩니다. **경로 압축(Path Compression)** 최적화로 성능을 높입니다.
  - **시간 복잡도**: O(α(N)) (거의 상수 시간)
  - **예시**: 크루스칼 알고리즘에서 사이클 판별, 동적 연결성 검사

- **위상 정렬 (Topological Sort)**
  - **목적**: 방향 그래프(DAG)에서 선후 관계를 위배하지 않도록 정점을 나열합니다. (주로 BFS, DFS로 구현)
  - **시간 복잡도**: O(V + E)
  - **예시**: 선수 과목 순서 결정, 의존성을 갖는 작업 순서 정렬

- **누적 합 (Prefix Sum)**
  - **목적**: 배열 원소의 **변경이 없는** 상황에서, **여러 번의 구간 합 질의**를 빠르게 처리할 때 사용합니다.
  - **시간 복잡도**: 전처리 O(N), 질의 O(1)

- **세그먼트 트리 (Segment Tree)**
  - **목적**: 누적 합과 달리, **구간 질의와 데이터 변경이 모두 빈번할 때** 사용합니다. 데이터가 변경되면 누적 합은 O(N)이 걸리지만, 세그먼트 트리는 O(log N)만에 수정할 수 있습니다.
  - **시간 복잡도**: 생성 O(N), 질의/갱신 O(log N)

- **투 포인터 (Two Pointers)**
  - **목적**: 1차원 배열에서 두 포인터를 조작하여 조건을 만족하는 부분을 찾습니다.
  - **시간 복잡도**: O(N)
  - **예시**: 정렬된 배열에서 합이 K인 두 수 찾기, 부분 연속 수열의 합이 M인 경우 찾기

- **우선순위 큐 (Priority Queue)**
  - **목적**: 우선순위가 가장 높은 데이터가 먼저 나오는 자료구조. **최소 힙(Min Heap)** 또는 **최대 힙(Max Heap)**으로 구현됩니다.
  - **시간 복잡도**: 삽입/삭제 O(log N), 최솟값/최댓값 확인 O(1)
  - **예시**: 다익스트라 알고리즘, 가장 작은/큰 N개 원소 찾기, 이벤트 시뮬레이션